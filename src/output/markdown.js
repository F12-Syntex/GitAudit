/**
 * Markdown report generation
 */

import { writeFile } from 'fs/promises';
import chalk from 'chalk';
import { categorizeWork, getAnalysisStats } from '../commits/analyze.js';

/**
 * Generate full markdown report from analysis
 * @param {Object} analysis - Complete analysis object
 * @param {Object} options - Formatting options
 * @returns {string} Markdown content
 */
export function generateMarkdownReport(analysis, options = {}) {
  const { repoInfo, analyses, summary, stats } = analysis;

  const sections = [];

  // Title
  sections.push(`# Contributions to ${repoInfo.name}\n`);

  // Repository info
  if (repoInfo.description) {
    sections.push(`> ${repoInfo.description}\n`);
  }

  // AI-generated summary (if available)
  if (summary?.summary) {
    sections.push(summary.summary);
    sections.push('');
  }

  // Statistics section
  sections.push(generateStatsSection(stats, repoInfo));

  // Detailed contributions (if not included in summary)
  if (!summary?.summary && analyses?.length > 0) {
    sections.push(generateContributionsSection(analyses));
  }

  // Footer
  sections.push('\n---');
  sections.push(`*Generated by GitAudit on ${new Date().toLocaleDateString()}*`);

  if (analysis.totalUsage) {
    sections.push(`*Tokens used: ${analysis.totalUsage.totalTokens}*`);
  }

  return sections.join('\n');
}

/**
 * Generate statistics section
 * @param {Object} stats - Analysis statistics
 * @param {Object} repoInfo - Repository info
 * @returns {string} Markdown section
 */
function generateStatsSection(stats, repoInfo) {
  const lines = ['## Statistics\n'];

  lines.push(`| Metric | Value |`);
  lines.push(`|--------|-------|`);
  lines.push(`| Total Commits | ${stats.totalCommits || 0} |`);

  if (stats.totalAdditions !== undefined) {
    lines.push(`| Lines Added | +${stats.totalAdditions} |`);
  }
  if (stats.totalDeletions !== undefined) {
    lines.push(`| Lines Removed | -${stats.totalDeletions} |`);
  }
  if (stats.filesChanged !== undefined) {
    lines.push(`| Files Changed | ${stats.filesChanged} |`);
  }

  // Languages
  if (repoInfo.languages && Object.keys(repoInfo.languages).length > 0) {
    const topLangs = Object.entries(repoInfo.languages)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([lang]) => lang)
      .join(', ');
    lines.push(`| Languages | ${topLangs} |`);
  }

  lines.push('');

  // Category breakdown
  if (stats.byCategory) {
    lines.push('### Contributions by Type\n');
    const categories = Object.entries(stats.byCategory)
      .filter(([_, count]) => count > 0)
      .sort((a, b) => b[1] - a[1]);

    for (const [category, count] of categories) {
      const emoji = getCategoryEmoji(category);
      lines.push(`- ${emoji} **${capitalizeFirst(category)}**: ${count} batch${count !== 1 ? 'es' : ''}`);
    }
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Generate contributions section from analyses
 * @param {Object[]} analyses - Batch analyses
 * @returns {string} Markdown section
 */
function generateContributionsSection(analyses) {
  const categorized = categorizeWork(analyses);
  const lines = ['## Key Contributions\n'];

  // Order categories by importance
  const categoryOrder = ['feature', 'bugfix', 'performance', 'refactor', 'test', 'docs', 'chore', 'style', 'other'];

  for (const category of categoryOrder) {
    const items = categorized[category];
    if (!items || items.length === 0) continue;

    const emoji = getCategoryEmoji(category);
    lines.push(`### ${emoji} ${capitalizeFirst(category === 'bugfix' ? 'Bug Fixes' : category + 's')}\n`);

    // Sort by importance and take top items
    const sorted = items
      .sort((a, b) => (b.importance || 0) - (a.importance || 0))
      .slice(0, 10);

    for (const item of sorted) {
      const date = item.batch.startDate
        ? new Date(item.batch.startDate).toLocaleDateString('en-US', { month: 'short', year: 'numeric' })
        : '';

      lines.push(`- **${item.description}** ${date ? `(${date})` : ''}`);

      if (item.detailedAnalysis) {
        // Add detailed analysis as sub-content
        const detail = item.detailedAnalysis.split('\n').slice(0, 2).join(' ').slice(0, 200);
        lines.push(`  ${detail}${item.detailedAnalysis.length > 200 ? '...' : ''}`);
      }

      // Add commit count if multiple
      if (item.batch.commits.length > 1) {
        lines.push(`  *${item.batch.commits.length} commits*`);
      }
    }

    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Generate a single repo section (for multi-repo reports)
 * @param {Object} analysis - Analysis for one repo
 * @returns {string} Markdown section
 */
export function generateRepoSection(analysis) {
  const { repoInfo, summary, stats } = analysis;

  const lines = [];
  lines.push(`### ${repoInfo.name}`);

  if (repoInfo.description) {
    lines.push(`*${repoInfo.description}*\n`);
  }

  if (summary?.summary) {
    // Extract just the overview if possible
    const overviewMatch = summary.summary.match(/##?\s*Overview\s*\n+([\s\S]*?)(?=##|$)/i);
    if (overviewMatch) {
      lines.push(overviewMatch[1].trim());
    } else {
      lines.push(summary.summary.split('\n').slice(0, 5).join('\n'));
    }
  }

  lines.push(`\n**Stats:** ${stats.totalCommits} commits | +${stats.totalAdditions || 0}/-${stats.totalDeletions || 0} lines\n`);

  return lines.join('\n');
}

/**
 * Export report to file
 * @param {string} content - Markdown content
 * @param {string} filename - Output filename
 */
export async function exportToFile(content, filename) {
  await writeFile(filename, content, 'utf-8');
  console.log(chalk.green(`Report exported to ${chalk.bold(filename)}`));
}

/**
 * Display report in terminal
 * @param {Object} analysis - Analysis object
 */
export function displayReport(analysis) {
  const { repoInfo, summary, stats } = analysis;

  console.log(chalk.cyan('\n' + '='.repeat(60)));
  console.log(chalk.bold.cyan(`  Contributions to ${repoInfo.name}`));
  console.log(chalk.cyan('='.repeat(60) + '\n'));

  // Stats
  console.log(chalk.bold('Statistics:'));
  console.log(`  Commits: ${chalk.yellow(stats.totalCommits || 0)}`);
  if (stats.totalAdditions !== undefined) {
    console.log(`  Lines: ${chalk.green(`+${stats.totalAdditions}`)} / ${chalk.red(`-${stats.totalDeletions}`)}`);
  }
  if (stats.filesChanged) {
    console.log(`  Files changed: ${chalk.yellow(stats.filesChanged)}`);
  }

  // Category breakdown
  if (stats.byCategory) {
    console.log('\n' + chalk.bold('By type:'));
    const categories = Object.entries(stats.byCategory)
      .filter(([_, count]) => count > 0)
      .sort((a, b) => b[1] - a[1]);

    for (const [category, count] of categories) {
      const emoji = getCategoryEmoji(category);
      console.log(`  ${emoji} ${capitalizeFirst(category)}: ${count}`);
    }
  }

  // Summary
  if (summary?.summary) {
    console.log('\n' + chalk.bold('Summary:'));
    console.log(chalk.dim('─'.repeat(60)));
    console.log(summary.summary);
    console.log(chalk.dim('─'.repeat(60)));
  }

  // Token usage
  if (analysis.totalUsage) {
    console.log(chalk.dim(`\nTokens used: ${analysis.totalUsage.totalTokens}`));
  }

  console.log('');
}

/**
 * Get emoji for category
 * @param {string} category - Category name
 * @returns {string} Emoji
 */
function getCategoryEmoji(category) {
  const emojis = {
    feature: '+',
    bugfix: '!',
    refactor: '*',
    docs: '#',
    test: '?',
    performance: '>',
    chore: '-',
    style: '~',
    other: '.',
  };
  return emojis[category] || '.';
}

/**
 * Capitalize first letter
 * @param {string} str - String to capitalize
 * @returns {string} Capitalized string
 */
function capitalizeFirst(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
